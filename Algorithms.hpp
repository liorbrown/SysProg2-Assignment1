// liorbrown@outlook.co.il

#pragma once

#include "Graph.hpp"

namespace graph{

    // This is static class that contains algorithms on graphs
    class Algorithms{
        private:
            /// @brief Declare private constructor for disable instantiation
            Algorithms(){}
            
            /// @brief Sets PI attribute of each vertex, to pioint to its previous vertex in the shortest path
            /// @param g Graph to sets its vertices
            /// @param s Source vertex
            static void setPI(Graph& g, Vertex* s);

            /// @brief Init attributes of all graph vertics
            /// @param g Graph to work on
            static void initAttributes(Graph& g);

            /// @brief Build new graph according to PI attribute of all vertices
            /// @param g Sorce graph to work on
            /// @return The new Graph
            static Graph* buildGraph(Graph& g);

            /// @brief Visit of dfs in some vertex
            /// @param g Graph to work on
            /// @param v Source vertex of current dfs visit
            static void dfsVisit(Graph& g, Vertex* v);

            /// @brief Decrease (or not) given the d of vertex u, using given edge from vertex v
            /// @param e Edge to use its weight
            /// @param v Vertex to use for decrease other edge vertex
            static void relax(const Edge& e, Vertex* v);

            /// @brief Check if given graph is connected
            /// @param g Graph to check
            /// @return True - if graph is connected, false otherwise
            static bool isConnect(Graph& g);

        public:
            /// @brief Finds shortest path from s to all other vertices. ignores edges weight
            /// @param g Graph to work on
            /// @param s Source vertex
            /// @return Tree that represent the shortest path from s to each vertex
            static Graph* bfs(Graph& g, const unsigned int s);

            /// @brief Runs dfs method on given graph
            /// @param g Graph to work on
            /// @param s Source vertex to start dfs visits from it
            /// @return Forest graph that generated by dfs algorithm
            static Graph* dfs(Graph& g, const unsigned int s);

            /// @brief Finds shortest path from s to all other vertices, according to edges weight
            /// NOTE: dijkstra works only on non-negative graphs
            /// @param g Graph to work on
            /// @param s Source vertex
            /// @return Tree that represent the shortest path from s to each vertex
            static Graph* dijkstra(Graph& g, const unsigned int s);

            /// @brief Find MST of given connected graph, using prim algorithm
            /// @param g Graph to work on
            /// @return The MST tree
            static Graph* prim(Graph& g);

            /// @brief Find MST of given connected graph, using kruskal algorithm
            /// @param g Graph to work on
            /// @return The MST tree
            static Graph* kruskal(Graph& g);
    };
}